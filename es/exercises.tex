\chapter{Tipos de Ejercicios}\label{s:exercises}

Todo buen carpintero tiene un juego de destornilladores y todo buen docente tiene diferentes tipos de ejercicios para comprobar qué están aprendiendo realmente los alumnos y las alumnas, para ayudarlos a practicar sus nuevas habilidades, y para mantener su  compromiso.

Este capítulo comienza describiendo varios tipos de ejercicios que se pueden usar para corroborar si tu forma de enseñar ha resultado efectiva.

Luego examina el estado del arte en cuanto a calificación automatizada, y culmina con la exploración de la discusión, proyectos y otros tipos importantes de trabajo que requieren una atención más humana para evaluar.

Nuestra discusión se basa parcialmente en el banco de preguntas \hreffoot{http://web-cat.org/questionbank/}{Canterbury Question Bank}~\cite{Sand2013}, que trae entradas para varios lenguajes de programación y temas introductorios a las ciencias de la computación.

\seclbl{Los clásicos}{s:exercises-classics}

Como se discute en \secref{s:models-formative-assessment}, las \emph{preguntas de opción múltiple} (PMC)  son más efectivas cuando las respuestas incorrectas sondean conceptos erróneos.  
Están designadas para evaluar los niveles más bajos en la taxonomía de Bloom\index{Bloom's Taxonomy}
(\secref{s:process-objectives}) ,pero también puede requerir que los/las estudiantes utilicen su propio juicio/criterio.

\begin{aside}{Una pregunta de opción múltiple}
  En qué orden ocurren las operaciones cuando la computadora evalúa la expresión \texttt{precio\ =\ agregarImpuestos(costo\ -\ descuento)}?
  \begin{enumerate}
  \item
    resta, llamado a función, asignación
  \item
    llamado a función, resta, asignación
  \item
    llamado a función, luego asignación y resta simultáneamente
  \item
    ninguna de las anteriores
  \end{enumerate}
\end{aside}


El segundo tipo de ejercicio de programación clásico es \emph{códificar y ejecutar} (C\&R, por sus siglas en inglés),
donde el estudiante escribe un código que produce una salida especificada. 
Los ejercicios C\&R pueden ser tan simples o complejos como el docente o la docente quieran, pero cuando se usen en clase deben ser breves y deben tener solamente una o dos respuestas correctas posibles.
Generalmente es suficiente con pedir a quienes se inician que calculen e impriman un solo valor o que llamen a una función específica:

Docentes experimentados frecuentemente se olvidan de cuán difícil puede ser darse cuenta de cuál parámetro van en qué lugar.
Para los estudiantes y las estudiantes  más avanzados, darse cuenta de cuál es la función que hay que llamar, es una actividad más atractiva y una mejor evaluación de su comprensión.

\begin{aside}{Programa \& ejecuta}
La variable \texttt{picture}contiene una imagen a todo color de un archivo.
Usando una función,
crea una versión blanco y negro de la imagen
y asígnala a una variable nueva llamada \texttt{monochrome}.
\end{aside}

Los ejercicios de escribir y ejecutar pueden ser combinados con MCQ.
Por ejemplo,
este MCQ sólo puede ser contestado ejecutando el comando Unix \texttt{ls}:

\begin{aside}{Combinar MCQ con Programar \& ejecutar}
  Estás en el directorio  \texttt{/home}.
  ¿Cuál de los siguientes archivos está\emph{no está} en dicho directorio?
  \begin{enumerate}
  \item
    \texttt{autumn.csv}
  \item
    \texttt{fall.csv}
  \item
    \texttt{spring.csv}
  \item
    \texttt{winter.csv}
  \end{enumerate}
\end{aside}

Los ejercicios de C\&Rs ayudan a practicar las habilidades que más quieren aprender,
pero pueden ser  difíciles de evaluar:
puede haber muchos caminos posibles para obtener la respuesta correcta,
y se genera desánimo si el sistema de evaluación rechaza el código elaborado porque no se corresponde con el del docente.
Una forma de reducir cuán frecuentemente ocurre esto es evaluar solo la salida,
pero esto no da feedback sobre cómo están programando.
Otra manera es darles un pequeño conjunto de pruebas con el que puedan comparar su código antes de enviarlo
(ya que se corre/ejecuta contra un conjunto de pruebas más completo).
Hacer esto les ayuda a descubrir si han malinterpretado completamente la intención del ejercicio antes de hacer cualquier cosa que pueda afectarles la nota.

En vez de escribir código que satisface una cierta especificación, 
se les puede pedir a los/las estudiantes y a las estudiantes que escriban pruebas que determinen si un fragmento de código satisface una cierta especificación. 
Esta es una habilidad útil por sí misma, y al hacerlo puede generar en los/las estudiantes un poco más de simpatía por lo duro que trabajan sus profesores.

\begin{aside}{Invirtiendo programar \& ejecutar}
 La función \texttt{monotonic\_sum} calcula la suma de una lista de números de una sección, en la que los valores aumentan estrictamente.

Por ejemplo,
  dada la entrada \texttt{[1,\ 3,\ 3,\ 4,\ 5,\ 1]},
  la salida es  \texttt{[4,\ 12,\ 1]}.

Escribe y corre pruebas unitarias para determinar cuál de los siguientes errores está contenido en la función :

   \begin{itemize}
  \item
    Considera cada número negativo como el inicio de una nueva sub-secuencia.
  \item
    No incluye el primer valor de cada sub-secuencia en la sub-suma.
  \item
    No incluye el último valor de cada sub-secuencia en la sub-suma.
  \item
    Solo reinicia la suma cuando los valores decrecen en vez de aumentar.
  \end{itemize}
\end{aside}


\emph{Llenar los espacios en blanco} es un refinamiento de C\&R
donde se le da al estudiante y a la estudiante  el comienzo de un código y debe completarlo

(En la práctica, la mayoría de los ejercicios C\&R son en realidad del tipo completar los espacios en blanco porque el docente o la  docente proveen comentarios
para recordarles a los estudiantes los pasos que deben seguir. 
Las preguntas de este tipo son la bases para  ejemplos descoloridos;
como se discute en \chapref{s:architecture},
las personas principiantes encuentran este tipo de ejercicios  menos intimidante que escribir todo el código desde cero,
y como el docente o la docente ha provisto la mayor parte de la estructura de la respuesta,
las respuestas enviadas son más predecibles y fáciles de revisar.

\begin{aside}{Completar los espacios en blanco}
 Completa los espacios en blanco,
 para que el código de abajo imprima el texto  \texttt{'hat'}.

\begin{minted}{text}
text = 'todo lo que es'
slice = text[____:____]
print(slice)
\end{minted}
\end{aside}

Los problemas de Parsons \index{Parsons Problem} también evitan el problema de la ``pantalla blanca del terror'' y permiten que los alumnos y las alumnas se concentren en el control del flujo separadamente del vocabulario \cite{Pars2006,Eric2015,Morr2016,Eric2017}.

Existen herramientas  en línea para construir y hacer Problemas de Parsons~\cite{Ihan2011},
pero pueden ser emuladas (aunque torpemente) 
pidiendo a los/las estudiantes que reorganicen líneas de código en un editor de texto.

\begin{aside}{Problemas de Parsons}
  Reordena e indenta estas líneas para sumar los valores positivos en una lista.
  (Agrega también punto y coma en lugares apropiados.)

\begin{minted}{text}
total = 0
if v > 0
total += v
for v in values
\end{minted}
\end{aside}

Dar más líneas de las que necesitan los/las estudiantes, o pedirles que reordenen algunas líneas y añadan otras más, hace que los problemas de Parsons sean significativamente más difíciles~\cite{Harm2016}.

\seclbl{Seguir}{s:exercises-tracing}

\emph{Seguir la ejecución} es lo contrario de un Problema de Parsons: 
dadas unas pocas líneas de código, 
los/as estudiantes tienen que trazar el orden en el que se ejecutan esas líneas.
Esta es una habilidad esencial de depuración\index{debugging}
 y una buena manera de consolidar la comprensión de los bucles, los condicionales y el orden de evaluación de las llamadas a funciones y a métodos.

La forma más fácil de implementarlo es hacer que los alumnos y las alumnas escriban una secuencia de pasos etiquetados.
Hacer que elijan la secuencia correcta de un conjunto 
(es decir, presentarla como un MCQ) 
añade carga cognitiva pero sin añadir valor, 
ya que tienen que hacer todo el trabajo descifrar cuál es la secuencia correcta, y luego buscarla en la lista de opciones.

\begin{aside}{Seguir el orden de ejecución}
  En qué orden se ejecutan las líneas etiquetadas de este bloque de código?

\begin{minted}{text}
A)     vals = [-1, 0, 1]
B)     inverse_sum = 0
       try:
           for v in vals:
C)             inverse_sum += 1/v
       except:
D)         pass
\end{minted}
\end{aside}

\emph{Seguir los valores} es similar a trazar la ejecución, 
pero en lugar de listar el orden en que se ejecuta el código, 
el estudiante enumera los valores que una o más variables asumen
 a medida que el programa se ejecuta.

Una forma de implementar esto es dar al estudiante y a la estudiante una tabla 
cuyas columnas están etiquetadas con nombres de variables 
y cuyas filas estén etiquetadas con números de línea, 
y pedirle que complete los valores que toman las variables en esas líneas.

\newpage
\begin{aside}{Seguir los valores}
  ¿Qué valores toman \texttt{left} y \texttt{right} a medida que este programa se ejecuta?

\begin{minted}{text}
A) left = 23
B) right = 6
C) while right:
D)     left, right = right, left % right
\end{minted}
\end{aside}

\begin{center}
\begin{tabular}{|l|l|l|}
  \hline
  Line & \texttt{left} & \texttt{right} \\
  \hline
  & & \\
  \hline
  & & \\
  \hline
  & & \\
  \hline
  & & \\
  \hline
  & & \\
  \hline
  & & \\
  \hline
\end{tabular}
\end{center}

También puedes pedir a los alumnos y a las alumnas que rastreen el código hacia atrás para averiguar cuál debe haber sido la entrada para que el código produzca un resultado determinado~\cite{Armo2008}.


Estos problemas de  \emph{ejecución inversa} requieren razonamientos de búsqueda y deducción, 
y cuando la salida es un mensaje de error, 
ayudan a los/las alumnos/as a desarrollar habilidades valiosas de depuración.

\begin{aside}{Ejecución Reversa}
  Completa el valor numérico faltante en \texttt{values}
  que causó que esta función se interrumpa.

\begin{minted}{text}
values = [ [1.0, -0.5], [3.0, 1.5], [2.5, ___] ]
runningTotal = 0.0
for (reading, scaling) in values:
    runningTotal += reading / scaling
\end{minted}
\end{aside}

\emph{Minimal fix} exercises also help learners develop debugging skills.
Los ejercicios de \emph{ajuste mínimo} también ayudan a desarrollar habilidades de depuración.

Dadas unas pocas líneas de código que contienen un error, el estudiante o la estudiante deben encontrarlo y hacer un pequeño cambio para arreglarlo.

El cambio puede hacerse usando C\&R,
mientras que la identificación puede hacerse como una pregunta de opción múltiple.


\begin{aside}{Ajuste mínimo}
 Se asume que esta función comprueba 
 si un número se encuentra dentro de un rango.
 Haz un pequeño cambio para que la función realmente lo haga.

\begin{minted}{text}
def inside(point, lower, higher):
    if (point <= lower):
        return false
    elif (point <= higher):
        return false
    else:
        return true
\end{minted}
\end{aside}

Los ejercicios de \emph{Tema y variación}son similares, 
pero se pide al alumno o a la alumna que hagan una pequeña alteración que cambie el resultado de alguna manera específica 
en lugar de hacer un cambio para arreglar un error.
Los cambios permitidos pueden incluir cambiar el valor inicial de una variable, 
reemplazar una llamada de función por otra, 
intercambiar bucles internos y externos,
o cambiar el orden de las pruebas en un condicional complejo

De nuevo,
este tipo de ejercicio da a los estudiantes y a las estudiantes la oportunidad de practicar una habilidad útil para el mundo real:
la forma más rápida de producir el código que necesitan 
es ajustando un código que ya hace algo parecido.

\begin{aside}{Tema y variaciones}
  Cambiar el bucle interior de la siguiente 
  función para que llene el triángulo superior izquierdo de una imagen
  con un color especificado.

\begin{minted}{text}
function fillTriangle(picture, color) is
    for x := 1 to picture.width do
        for y := 1 to picture.height do
            picture[x, y] = color
        end
    end
end
\end{minted}
\end{aside}

Los \emph{Ejercicios de Modificación} son el complemento de los ejercicios de  tema y variación: 
dado un trozo de código que funciona, el estudiante y la estudiante tienen que modificarlo de alguna manera sin cambiar la salida.

Por ejemplo, 
el alumno o la alumna pueden reemplazar los bucles con expresiones vectorizadas
 o simplificar la condición en un bucle while

Esto también es una habilidad útil para la vida real, 
pero como hay tantas formas de modificar el código,
se necesita inspección humana para poder poner una nota.

\begin{aside}{Refactoring}
  Escribir una sola compresión de lista que tenga el mismo efecto que este bucle.

\begin{minted}{text}
result = []
for v in values:
    if len(v) > threshold:
        result.append(v)
\end{minted}
\end{aside}


\seclbl{Diagramas}{s:exercises-diagrams}

Hacer que los alumnos dibujen mapas conceptuales y otros diagramas, brinda una idea de cómo están pensando (\secref{s:memory-concept-maps}),
pero los diagramas de forma libre requieren tiempo y juicio humano para evaluarlos.

\emph{Etiquetar los diagramas},
por otra parte, 
es pedagógicamente igual de poderoso 
pero mucho más fácil de escalar.

En lugar de hacer que los alumnos y las alumnas creen diagramas desde cero, hay que proporcionarles un diagrama y un conjunto de etiquetas y hacer que las coloquen en  los lugares correctos.
El diagrama puede ser una estructura de datos (``después de ejecutar este código, ¿qué variables apuntan a qué partes de esta estructura?''), un gráfico (``aparea cada uno de estos fragmentos de código con la parte del gráfico generado''), o el propio código (``haz coincidir cada término con un ejemplo del mismo en el programa'').

\begin{aside}{Etiquetar un diagrama}
  \figref{f:exercises-labeling} muestra
cómo un fragmento pequeño de HTML se representa en memoria.
  Pon las etiquetas 1--9 sobre los elementos del árbol 
  para mostrar el orden de llegada cuando se hace recorrido en profundidad.
\end{aside}


\figpdf{figures/labeling.pdf}{Etiquetando un diagrama}{f:exercises-labeling}


Otra forma de usar los diagramas es darles a los alumnos y a las alumnas partes del diagrama y pedirles que las ordenen correctamente.

Este es un equivalente visual de un Problema de Parsons, 
y se puede proporcionar tanto más o menos del esquema para ayudar con la colocación de las etiquetas como se considere apropiado.

Tengo buenos recuerdos tratando de colocar resistencias y capacitores en un circuito para obtener el voltaje correcto en un punto determinado, y he visto profesores que le dan a sus alumnas un conjunto definido de bloques de Scratch\index{Scratch} y les piden que creen un diseño particular usando sólo esos bloques.

Los \emph{Problemas de Correspondencia} pueden pensarse como un caso especial de etiquetado 
en el que el ``diagrama'' es una columna de texto 
y las etiquetas se toman de la otra columna.

En la \emph{Correspondencia Uno-a-uno} se le da al estudiante o a la estudiante dos listas de igual longitud y se le pide que asocie los elementos correspondientes, 
e.g.\ ``asocia cada fragmento de código con la salida que produce''.

\begin{aside}{Correspondencia}
  Asocia cada operador de expresión regular en \figref{f:exercises-matching}
  con lo que hace.
\end{aside}

\figpdfhere{figures/matching.pdf}{Matching items}{f:exercises-matching}

Con la \emph{correspondencia de muchos a muchos} las listas no tienen la misma longitud, por lo que algunos elementos pueden asociarse con varios
y otros pueden no tener correspondencias.

Las correspondencias muchos-a-muchos son más difíciles 
porque los/las estudiantes no pueden hacer los apareamientos fáciles primero para reducir su espacio de búsqueda.

Los problemas de correspondencia pueden ser implementados haciendo que los/las alumnos/as envíen listas de ítems apareados 
(como ``A3, B1, C2''), 
pero eso es burdo y propenso a errores.

Hacer que reconozcan un conjunto de pares correctos en un MCQ es aún peor, 
ya que es muy fácil de malinterpretar, lamentablemente .

Dibujar o arrastrar funciona mucho mejor, 
pero puede requerir más trabajo para implementarlo.


\emph{Ranking} es un caso especial de emparejamiento 
que es (ligeramente) más fácil de responder mediante listas, 
ya que nuestras mentes son bastante buenas para detectar errores o anomalías en las secuencias.
Los criterios de ranking determinan el nivel de razonamiento requerido.

Si haces que los alumnos y las alumnas ordenen los algoritmos de ranking del más rápido al más lento, probablemente estés ejercitando su memoria 
(es decir\  pidiéndoles que reconozcan los nombres de los algoritmos y sus propiedades), mientras que al pedirles que clasifiquen las soluciones desde las más robustas a las más frágiles, ejercitas su razonamiento y el juicio.

\emph{Resumir} también requiere que los/as alumnos/as utilicen un pensamiento de orden superior y les da la oportunidad de practicar una habilidad que es muy útil para informar sobre errores.
Por ejemplo, 
se puede les preguntar a los alumnos y a las alumnas,
 ``¿Qué frase describe mejor cómo cambia la salida de f a medida que  x varía de 0 a 10?'' 
y luego se les dan varias opciones como una pregunta de opción múltiple.

También puedes pedir respuestas muy cortas de formato libre a preguntas en dominios restringidos, como por ejemplo, ``¿Cuál es la característica clave de un algoritmo de ordenamiento que sea estable?''
No podemos automatizar completamente la comprobación de las respuestas sin generar un número frustrante de falsos positivos 
(aceptando respuestas erróneas) 
y falsos negativos (rechazando las correctas), 
pero las preguntas de este tipo se prestan bien a la clasificación por pares 
(\secref{s:individual-peer}).

\seclbl{Calificación automática}{s:exercises-grading}
\index{automatic grading}

Las herramientas de corrección automática han existido desde antes que yo naciera: la primera mención publicada data de 1960, y las encuestas publicadas por~\cite{Douc2005,Ihan2010} nombran muchas herramientas específicas.

Construir tales herramientas es mucho más complejo de lo que podría parecer a primera vista.

¿Cómo se representan las tareas?

¿Cómo se rastrean y reportan los envíos de tareas?

¿Pueden los/as alumnos/as trabajar cooperativamente?

¿Cómo se pueden enviar las tareas de manera segura?

\cite{Edwa2014a} es un artículo entero dedicado a un esquema adaptativo para detectar y gestionar bucles infinitos de los envíos de código, y esa es sólo una de las muchas cuestiones que surgen.

Cuando se habla de autocalificadores, 
es importante diferenciar la satisfacción de los/las estudiantes de los resultados del aprendizaje.
Por ejemplo, 
\cite{Magu2018} sustituyó los laboratorios informales de programación de un curso de CS de segundo año por una prueba semanal evaluada utilizando un autocalificador.
A los/as alumnos/as no les gustó el sistema automatizado, 
pero la tasa general de fracasos del curso se redujo a la mitad 
y se triplicó el número de alumnos/as que obtuvieron calificaciones distinguidas.
Por el contrario , 
\cite{Rubi2014} también comenzó a utilizar un autocalificador diseñado para competencias, pero no vio una disminución significativa en la tasa de abandono de sus alumnos y alumnas;
una vez más, 
los alumnos y las alumnas hicieron comentarios negativos sobre la herramienta, 
que los autores atribuyeron a la calidad de los mensajes de retroalimentación más que a una aversión a la autocalificación.

\cite{Srid2016} adoptaron un enfoque diferente.
Utilizaron \gref{g:fuzz-testing}{fuzz testing} 
(es decir, fuzzing o fuzz testing, casos de prueba generados al azar) 
para comprobar si el código del alumno/a hace lo mismo que una implementación de referencia suministrada por el profesor.
En el primer proyecto de un curso introductorio de 1400 alumnos y alumnas, el fuzz testing identificó errores que no fueron detectados por un conjunto de casos de prueba escritos a mano para más del 48 % de los alumnos.

\cite{Basu2015}  dio a sus estudiantes una serie de soluciones a casos de prueba, 
pero tenían que desbloquear cada caso respondiendo a preguntas sobre su comportamiento esperado
antes de poder aplicar la solución propuesta.

Por ejemplo, 
supongamos que los/as alumnos/as tuvieran que escribir una función para encontrar el mayor par de números adyacentes en una lista.Antes de que se les permitiera usar las pruebas de la pregunta, tenían que elegir la respuesta correcta a, ``¿Qué hace  \texttt{largestPair(4, 3, -1, 5, 3, 3)}''.
En un curso universitario de 1300 personas, 
la gran mayoría de los estudiantes y las estudiantes eligió validar su comprensión sobre los casos de prueba de esta manera 
antes de intentar resolver los problemas, 
y luego hicieron menos preguntas y expresaron menos confusión sobre las tareas.

\begin{aside}{Contra las herramientas disponibles en el mercado}
Es tentador usar herramientas de revisión de estilo fácilmente disponibles para calificar el código de los/las estudiantes.
Sin embargo,
\cite{Nutb2016} inicialmente no encontró correlación entre las calificaciones proporcionadas por personas 
y las violaciones a las reglas del corrector de estilo.
A veces esto se debía a que los alumnos y las alumnas violaban una regla muchas veces 
(perdiendo así más puntos de los que debían), 
pero otras veces se debía a que enviaban el código de inicio de tarea con pocas alteraciones y obtenían más puntos de los que debían.

 Incluso herramientas construidas específicamente para la enseñanza pueden no estar a la altura de las necesidades de los profesores.
   \cite{Keun2016a,Keun2016b}  observaron los mensajes producidos por 69 herramientas de autocalificación.
  Encontraron que a menudo las herramientas de autocalificación no dan retroalimentación sobre cómo arreglar los problemas y dar el siguiente paso.
    También encontraron que la mayoría de los docentes y las docentes no pueden adaptar fácilmente la mayoría de las herramientas a sus necesidades: 
como muchas herramientas de flujo de trabajo, tienden a hacer cumplir supuestos no reconocidos por sus creadores, sobre el funcionamiento de sus instituciones.
  Su esquema de clasificación es una lista de compras útil cuando se examinan herramientas de este tipo.
\end{aside}

\cite{Buff2015} presenta una reflexión bien documentada sobre la idea de proporcionar una retroalimentación automatizada.
Su punto de partida es que, 
``Los sistemas de calificación automatizados ayudan a los/las estudiantes a identificar los errores en su código, 
[pero] pueden inadvertidamente desalentarlos de pensar en forma crítica y a realizar pruebas exhaustivas, 
fomentando en cambio  la dependencia de las pruebas del profesor''.
Una de las cuestiones clave que identificaron es que un estudiante o una estudiante pueden probar exhaustivamente su código, pero puede no ser implementado de acuerdo con las especificaciones del profesor.
En este caso, 
el ``fallo'' no se debe a la falta de pruebas sino a un malentendido de los requisitos, y es poco probable que más pruebas expongan el problema.
Si el sistema de autocalificación no proporciona una retroalimentación que brinde una mejor comprensión y aplicación de los conocimientos, esta experiencia sólo frustrará al alumno/a.
Para proporcionar esa retroalimentación, 
el sistema de \cite{Buff2015} identifica qué métodos son ejecutados por las pruebas fallidas del código del alumno 
para que el sistema pueda asociar dichas fallas con características particulares de lo que envío el alumno/a.
El sistema decide si se han ``ganado'' ayudas específicas viendo si el alumno ha testeado lo suficiente la característica asociada, para evitar que se apoye en las ayudas en vez de realizar las pruebas.
En \cite{Srid2016} se describen otros enfoques para compartir la retroalimentación con los/las estudiantes 
cuando  estaban testeando automáticamente su código.
Lo primero es proporcionar la salida esperada para las pruebas---pero 
luego los alumnos generan salidas hard-code para esas entradas 
(porque todo lo que se puede hacer se hace).

Lo segundo es informar  los resultados de la aprobación o rechazo del código de los alumnos, 
pero suministrando las entradas y salidas reales de las pruebas sólo después de la fecha de envío.
Sin embargo, 
es frustrante decirles a los alumnos que se equivocaron sin decirles por qué.
Una tercera opción es utilizar una técnica llamada ``hashing'' para generar un valor que depende de la salida pero sin revelarla.

Si el usuario produce exactamente el resultado correcto
su hash desbloqueará la solución, 
pero es imposible hacer el camino inverso a partir del hash para averiguar cuál es resultado supuesto.

El hash requiere más trabajo y explicación para configurarlo, 
pero da un buen balance entre mostrar la respuesta de manera prematura y no revelarla cuando podría ser de ayuda.

\seclbl{Higher-Level Thinking}{s:exercises-higher}

Muchos tipos de ejercicios de programación son difíciles de evaluar por profesores en una clase con más de un puñado de alumnos y alumnas, e igualmente difícil para evaluar mediante plataformas automatizadas.
Las clases van desarrollándose con vistas a proyectos de programación mayores (si todo va bien) , 
pero la única manera de dar retroalimentación es caso por caso.
La \emph{Revisión de código} es, en general, también  difícil de calificar automáticamente,
pero puede ser abordada si se les da a los/las estudiantes una lista de fallos y se les pide que cotejen determinados comentarios con determinadas líneas de código.

Por ejemplo, 
se le puede decir a la alumna que hay dos errores de indentación y un nombre de variable malo y pedirle que los señale.

Si son alumnos/as más avanzados, se les podría dar una media docena de tipos de comentarios que podrían hacerse sobre el código sin que se les diga cuánto de cada uno debería encontrar.

\cite{Steg2016b} es un buen punto de partida para una rúbrica de estilo de código, mientras que~\cite{Luxt2009} muestra la revisión por pares en las clases de programación de manera más general.

Si se pide a los/las estudiantes que hagan revisiones, hay que usar la revisión por pares calibrada (\secref{s:individual-peer})\index{calibrated peer review} para que tengan modelos de cómo debería ser una buena retroalimentación.

\begin{aside}{Revisión de código}
 Marca los problemas en cada línea de código usando la rúbrica proporcionada.

\begin{minted}{text}
01)  def addem(f):
02)      x1 = open(f).readlines()
03)      x2 = [x for x in x1 if x.strip()]
04)      changes = 0
05)      for v in x2:
06)          print('total', total)
07)          tot = tot + int(v)
08)      print('total')
\end{minted}

   \begin{longtable}{ll}
    1. nombre de la variable malo   & 2. uso de variable indefinida \\
    3. falta el valor de salida & 4. variable no usada
  \end{longtable}

\end{aside}

\seclbl{Ejercicios}{s:exercises-exercises}

\exercise{Programar y ejecutar}{en pares}{10'}

Crea un ejercicio corto de C\&R, 
luego intercambia con un compañero 
y mira cuánto tiempo les toma a cada uno de ustedes entender y hacer el ejercicio del otro

¿Hubo alguna ambigüedad o malentendido en la descripción del ejercicio?

\exercise{Invertir el código y la ejecución}{grupos pequeños}{15'}

Forma grupos de 4 a 6 personas.
Haz que cada miembro del grupo cree un ejercicio de C\&R invertido que requiera que las personas averigüen qué entrada produce una salida en particular.
Elige dos al azar 
y mira cuántas entradas diferentes que satisfagan los requisitos puede encontrar el grupo.

\exercise{Siguiendo valores}{en pares}{10'}

Escribe un programa corto (10-15 líneas),
 intercambia con una compañera y 
traza cómo las variables del programa cambian de valor con el tiempo.
¿Qué diferencias hay en la forma en que tú y tu compañero escribieron sus trazas?

\exercise{Refactoring}{grupos pequeños}{15'}

Forma grupos de 3-4 personas.

Haz que cada persona seleccione un trozo corto de código que haya escrito  (de 10 a 30 líneas de largo) y que no sea tan ordenado como podría ser, 
luego elige una alumna al azar y haz que todos en el grupo lo ordenen independientemente.

¿En qué se diferencian las versiones limpias?
¿Qué tan bien o mal podrían acomodarse todas estas variaciones si se calificara automáticamente, o en una clase numerosa?

\exercise{Rotulando un Diagrama}{de a pares}{10'}

Dibuja un diagrama mostrando algo que se ha explicado recientemente: cómo los navegadores obtienen datos de los servidores, la relación entre los objetos y las clases,
o cómo se indexan los dataframes en R.

Pon las etiquetas en el lateral y pídele a tu compañera que las coloque.

\exercise{Acertijos de Lápiz y Papel}{toda la clase}{15'}

\cite{Butl2017} describe un conjunto de rompecabezas de lápiz y papel que pueden convertirse en asignaciones de programación introductorias, señalando que estas tareas son disfrutadas por los/as alumnos/as y que fomentan la meta-cognición.
Piensa en un simple acertijo o juego de lápiz y papel al que jugabas de niño 
y describe cómo lo convertirías en un ejercicio de programación.

\exercise{Contando Fallos}{de a pares}{15'}
Cualquier estimación útil de cuánto tiempo se necesita para resolver un ejercicio 
debe considerar cuán  frecuentes son los fallos y cuánto tiempo se pierde con ellos.
Por ejemplo, 
editar archivos de texto parece una tarea sencilla, 
pero ¿qué hay de localizar esos archivos?
La mayoría de los editores que usan interfase gráfica (GUI) guardan las cosas en el escritorio de la usuaria o en su directorio personal; si los archivos utilizados en un curso se almacenan en otro lugar, una proporción importante de los/las estudiantes no podrá navegar al directorio correcto sin ayuda.
(Si esto te parece un problema menor, por favor vuelve a la discusión del punto ciego de las personas expertas en \chapref{s:memory}.)


Trabajando con un compañero, haz una lista de las cosas ``simples'' que has notado que salen mal en los ejercicios que has usado o tomado.

¿Con qué frecuencia aparecen?

¿Cuánto tiempo tardan los alumnos en arreglarse solos o con ayuda?

¿Cuánto tiempo de clase asignas actualmente para tratarlos?


\exercise{Hablando de Tiempo}{individual}{10'}
¿Qué tan precisas han sido las estimaciones de tiempo de los ejercicios de este libro hasta ahora?
