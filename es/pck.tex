\chapter{Conociminto de la pedagoía del contenido}\label{s:pck}

Cada docente necesita tres cosas:

\begin{description}

\item[\gref{g:content-knowledge}{conocimiento del contenido}]
  por ejemplo, como programar;

\item[\gref{g:general-pedagogical-knowledge}{conocimiento general de pedagogía}]
  por ejemplo, comprensión de la psicología del aprendizaje;
  y

\item[\gref{g:pedagogical-content-knowledge}{conocimiento de la pedagoía del contenido}]
  (PCK por Pedagogical Content Knowledge en inglés),
  que es el conocimiento específico de cómo enseñar un concepto particular a una audiencia en particular. 
  En informática,
  PCK incluye cosas como qué ejemplos usar cuando se enseña como se incluyen parámentros en una función o que conceptos erroneos sobre etiquetas HTML anidadas son los más comunes.
\end{description}

Podemos agregar conocimiento técnico a este conjunto~\cite{Koeh2013},
pero eso no cambia en punto clave: no es suficiente saber sobre el tema y como enseñar---tienes que saber cómo enseñar ese tema en particular~\cite{Maye2004}.
Este capítulo resume algunos resultados de investigación sobre enseñanzan de informática para añadir a tu colección de PCK.

Como con toda investigación,
se requiere cierta precaución al interpretar los resultados:

\begin{description}

\item[Las teorías cambian a medida que se obtienen más datos.]
  La investigación en educación en informática (CER, por Computing education research en inglés) es una nueva diciplina:\index{computing education research}
  la Sociedad Americana de Educación en Ingeniería fue fundada en 1893 y el Concejo Nacional de Profesores de Matemática en 1920, pero la Asociación de Profesores de Informática no existió hasta 2005.
  Mientras que existe un flujo constante de nuevo conocimiento en conferencias como \hreffoot{http://sigcse.org/}{SIGCSE},
  \hreffoot{http://iticse.acm.org/}{ITiCSE},
  y \hreffoot{https://icer.hosting.acm.org}{ICER},
  simplemente no sabemos tanto sobre como aprender a programar como sabemos sobre aprender a leer, jugar un deporte o resolver cálculos simples.
  
\item[La mayoría de las personas en estos estudios son WEIRD:]\index{WEIRD}
  viven en sociedades occidentales, democráticas, industrializadas y con alto nivel de riqueza y educación (WEIRD por Western, Education, Industrialized, Rich, and Democratic en inglés)~\cite{Henr2010}.
  Además,
  son principalmente jóvenes en contextos formales, ya que es la población a la que la mayoría de las personas que investigan tienen fácil acceso. 
  Sabemos mucho menos sobre adultos, grupos marginados y estudiantes en contextos no formales o \grefdex{g:end-user-programmer}{end-user programmers}{end-user programmer},
  aún cuando son la mayoría.

\end{description}

Si esto fuera un ensayo académico, empezaría la mayotía de oraciones con frases como,
``Algunas investigaciones parece indicar que{\ldots}''
Pero dado que los y las docentes en las aulas tienen que tomar decisiones independientemente de si las investigaciones tienen respuestas claras o no, este capítulo presenta las mejores conjeturas prácticas en lugar de sutiles posibilidades 

\begin{aside}{Jerga}
  Como cualquier especialidad,
  CER tiene jerga.
  \gref{g:cs1}{CS1} refiere a un curso introductorio de un semestre de duración, donde los estudiantes aprenden variables, interaciones y funciones por primera vez, mientras que \gref{g:cs2}{CS2} refiere a un segundo curso que cubre las estructuras de datos básicas como  stacks y queues,
  y \gref{g:cs0}{CS0} refiere a un curso introductorio para personas sin experiencia previa y que no tienen intención de continuar con computación de inmediato.
  Las definiciones completas de estos términos se encuentran en\hreffoot{https://www.acm.org/education/curricula-recommendations}{Lineamientos del programa ACM}.
\end{aside}

\seclbl{¿Qué les estamos enseñando ahora?}{s:pck-now}

Se sabe muy poco sobre que enseñan en coding bootcamps e iniciativas free-range, en parte porque muchas personas son reticentes a compartir los programas.
Savemos maś sobre que se enseña en instituciones~\cite{Luxt2017}:

\begin{longtable}{llll}
\textbf{Temas}			& \textbf{\%}	& \textbf{Temas}		& \textbf{\%} \\
Proceso de programación     	& 87\%		& Tipos de datos                & 23\% \\
Pensamiento abstracto para programación	& 63\%		& Input/Output                  & 17\% \\
Estructura de datos      		& 40\%		& Librerías                     & 15\% \\
Conceptos orientados a objetos        & 36\%		& Variables y Asignación       & 14\% \\
Estructuras de control              & 33\%		& Recursion 			& 10\% \\
Operaciones y Funciones         & 26\%		& Punteros y administración de memoria	&  5\%
\end{longtable}

Títulos de temas de alto nivel como estos pueden esconder una gran cantidad de fallas.
Un resultado más tangible surge de \cite{Rich2017},
donde reivsa cien artículos para encontrar trayectorias de aprendizaje para clases de computación en escuelas primarias y secundarias.
Sus resultados para la secuenciación, la repetición y los condicionales son esencialmente mapas conceptuales colectivos
que combinan y racionalizan el pensamiento implícito y explícito de gran cantidad de educadoras/es.
(\figref{f:pck-trajectory}).

\newpage

\figpdfhere{../figures/conditionals.pdf}{Trayectoria de aprendizaje de condicionales (a partir de~\cite{Rich2017})}{f:pck-trajectory}

\seclbl{¿Cuánto están aprendiendo?}{s:pck-learning}

Puede haber un mundo de distancia entre lo que enseñan las/los docentes y cuanto aprenden las personas.
Para explorar lo último, debemos usar otras medidas o hacer estudios directos.
Tomando el primer enfoque, aproximadamente dos tercios de las/los estudiantes de nivel superior aprueban su primer curso de informática,
con algunas variaciones dependiendo del tamaño de la clase,
pero sin diferencias significativas a lo largo del tiempo o basadas en el lenguaje~\cite{Benn2007a,Wats2014}.

¿Cómo afecta la experiencia previa a estos resultados?\index{effect of prior experience}
Para responder esto, 
\cite{Wilc2018} compara el desempeño y la confianza de principiantes
con y sin experiencia previa en programación en CS1 y CS2 (ver más abajo).
Encontaron que principiantes con experiencia previa superaron a principiantes sin experiencia en un 10\% en CS1,
pero esas diferencias desarecieron hacía el final de CS2.
También encontraron que las muejres con experiencia previa superaron a sus pares masculinos en todas las áreas,
pero siempre tenián menos confianza en sus habilidades. (\secref{s:motivation-inclusivity}).

En cuanto a estudios sobre cuanto aprenden las/los principiantes,
\cite{McCr2001} presenta un estudio internacional en multiples espacios que luego fue replicado por~\cite{Utti2013}.
De acuerdo al primer estudio,
``{\ldots}los decepcionantes resultados sugieren que
muchas estudiantes no saben cómo programar al final de los cursos introductorios".
Más específicamente,
``Para una muestra combinada de 216 estudiantes de cuatro universidades,
la puntuación media fue de 22,89 sobre 110 puntos en los criterios generales de evaluación desarrollados para este estudio''
Este resultado puede hablar tanto de las expectativas de profesores como de la habilidad de estudiantes,
pero de cualquier manera,
nuestra primera recomendación es \recommendation{medir y hacer un seguimiento de los resultados}
de tal manera que se puedan comparar a través del tiempo para que puedas saber si tus lecciones se están volviendo más o menos efectivas.

\seclbl{¿Qué confusiones tiene las/los principiantes?}{s:pck-misunderstand}

\chapref{s:models} explicó porqué aclarar las confusiones de las/los principiantes es tan importante como enseñarles
estrategias para resolver problemas.
La mayor confusión de principiantes ---a veces llamada el ``superbug'' en programación ---es\index{superbug}
la creencias de que las computadoras entienden lo que las personas quieren decir de la misma manera que cualquier ser humano lo haría~\cite{Pea1986}.
Nuestra segunda recomendación es entonces \recommendation{enseñar a principiantes que las computadoras no entienden los programas},
es decir, que llamar a una variable ``precio'' no garantiza que su valor sea realmente un precio.

\cite{Sorv2018}  muestra más de cuarenta confusiones que docentes también pueden intentan aclarar,
muchas de las cuales tambié se discuten en la encuesta de~\cite{Qian2017}.
Una es la creencia de que las variables en los programas funcionan de la misma manera que en planillas de cálculo,
es decir, que luego de ejecutar:

\begin{minted}{text}
nota = 65
total = nota + 10
nota = 80
print(total)
\end{minted}

\noindent
el valor de \texttt{total} será 90 envez de 75~\cite{Kohn2017}.
Este es un ejemplo de la forma en que las/los principiantes construyen un modelo 
mental plausible pero erróneo haciendo analogías; otras confusiones incluyen:


\begin{itemize}

\item
  Una variable guarda la historia de los valores que le fueron asignando,
  es decir, recuerda que valor supo representar.

\item
  Está garantizado que dos objetos con el mismo valor el \texttt{nombre} 
  o atributo de identificación \texttt{id} son el mismo objeto.   
  

\item
  Las funciones son ejecutada cuando se las define,
  o son ejecutadas en el orden en que son definidas.

\item
  La condición de un bucle \texttt{while} se evalua constantemente,
  y el bucle se detiene tan pronto como se vuelve falso.
  Por el contrario,
  la condición en los \texttt{if} es constantemente evaluada,
  y sus declaraciones son ejecutadas tan pronto como la condición se vuelve verdadera
  sin importar el flujo de control en ese momento.

\item
  Las asignaciones modifican valores,
  es decir, después de \texttt{a\ =\ b}, la variable \texttt{b} está vacía.

\end{itemize}

\seclbl{¿Qué errores comenten las/los principiantes?}{s:pck-mistakes}

Los errores que comenten las/los principiantes nos indican que priorizar cuando enseñamos,
pero resulta que la mayoría de las personas que enseñan no saben lo comunes que son los diferentes tipos de errores.
El más grande de los estudios es \cite{Brow2017},
que encontró que la falta de paréntesis y comillas son el tipo de error más común en programas en Java de principiantes,
pero además son los más simples de resolver,
mientras que algunos errores (como poner la condición de un \texttt{if} en \texttt{\{\}} en vez de \texttt{()})
se comenten solo una vez.
No extraña que los errores que producen problemas de compilación son resueltos mucho más rápidamente
que aquellos que no lo hacen.
Algunos errores, en cambio, se repiten muchas veces, como llamar métodos con los agumentos incorrectos
(ej.\ pasar una cadena caracteres en vez de un entero).

\begin{aside}{No es correcto vs.\ No está resuelto}
  Una dificultad en una investigación como esta es distinguir los errores del trabajo en proceso.
  Por ejemplo,
  una estructura \texttt{if} vacía o un método que se define pero aún no se a usado
  puede ser señal de que el código está incompleto más que un error.
\end{aside}

\cite{Brow2017} también compara los errores que las/los principiantes realmente cometen 
con los que sus docentes pensaron que cometieron.
Descubrieron que,
``{\ldots}las/los docentes llegaron a un escaso concenso sobre cuales son los errores más frecuentes,
que sus clasificaciones tenían solo unaa correspondencia moderada con la de las/los estudiantes en los{\ldots}datos,
y que la experiencia de las/los docentes no tuvo ningún efecto en este nivel de acuerdo.''
Por ejemplo,
confundir \texttt{=} (asignación) y \texttt{==} (igualdad)
no eran tan común como la mayoría de las/los docentes creían.

\begin{aside}{No solo por el código}
  \cite{Park2015} recopiló datos de un editor HTML online durante un curso introductorio de desarrollo web
  y encontró que casi todas/os las estudiantes cometieron errores de sintaxis que permanecesieron sin ser resueltos por semanas durante el curso.
  El 20\% de esos errores están relacionados con reglas relativamente complejas
  que indican \emph{cuándo} qie los elementos HTML estén anidados entre si,
  pero el 35\% está relacionado a sistaxis de etiquetas más simples que determinan \emph{cómo} los elementos HTML están anidados.
  La tendencia de muchas/os docentes a decir,
  ``Pero las reglas son simples,''
  es un buen ejemplo del punto ciego de las personas expertas que se analiza en el \chapref{s:memory}{\ldots}
\end{aside}

\seclbl{¿Cómo programan las/los principiantes}{s:pck-programming}

\cite{Solo1984,Solo1986} fue pionero en la exploración de las estrategias de programación de principiantes y gente experta.
El hallazgo clave es que las personas expertas saben al mismo tiempo el ``que'' y el ``como,''
es decir, entienden que poner en los programas
\emph{y} tiene un conjunto de patrones o plan que guía la contrucción de los programas.\index{program patterns}
Las/los principiantes no tienen ninguna de las dos cosas,
pero la mayoría de las/los docentes se enfocan unicamente en el primero,
a pesar de que los errores son usualmente causados por no tener una estrategia para resolver el problema
en lugar de la falta de conocimiento sobre el lenguaje.
Un trabajo reciente mostró la efectividad de enseñar cuatro habilidades distintas en un orden específico~\cite{Xie2019}:

\begin{longtable}{lll}
		        & \textbf{semántic del código}   		& \textbf{plantillas asociadas a obejtivos} \\
\textbf{leyendo}	& 1.\ Lee el código y predice su comportamiento	& 3.\ reconoce plantillas y sus usos
\textbf{escribiendo}	& 2.\ Escribe sintaxis correcta		& 4.\ usa plantillas para alcanzar objetivos
\end{longtable}

Por lo tanto, nuestras próximas recomendaciones son
que \recommendation{estudiantes lean código, luego lo modifiquen, luego lo escriban},
e \recommendation{intruducir patrones comunes explicitamente y que las/los estudiantes practiquen usándolos}.
\cite{Mull2007b} es uno de los tantos estudios que muestran los beneficios de enseñar patrones comunes explicitamente y descomponer los problemas
en patrones comunes crea oportunidades naturalmente para generar y nombrar sub-objetivos~\cite{Marg2012,Marg2016}.\index{labeled subgoals}

\seclbl{¿Cómo resuelven errores las/los principiantes?}{s:pck-debug}

Una década atrás,
\cite{McCa2008} escribió,
``Es sorprendente el poco espacio que se dedica a los errores y como resolverlos
en la mayoría de los libros introductorios de programación.''
Poco ha cambiado esde entonces:
hay cientos de libros sobre compiladores y sistemas operativos,
pero solo unos pocos sobre resolución de errores,\index{debugging}
y nunca he visto un curso de pregrado dedicado a este tema.

\cite{List2004,List2009} encontró que muchas/os principiantes les cuesta predecir el resultado de cortas líneas de código
y seleccionar la salida correcta del código a partir de un conjunto de posibilidades
cuando les decían lo que se suponía que el código debía hacer. Más recientemente,
\cite{Harr2018} encontró que la brecha entre poder entender el código y poder escribirlo se ha cerrado en gran medida por CS2,
pero que a las/los principiantes que aún tienen esa brecha es probable que les vaya mal.

Nuestra quinta recomendación es entonces \recommendation{enseñar explicitamente a las/los principiantes como resolver errores}.
\cite{Fitz2008,Murp2008} encontraron que las personas que pueden resolver errores son buenas programando,
pero no todas las personas que son buenas programando son buenas resolviendo errores.
Aquellas personas que usaron un depurador de errores simbólico para recorrer sus programas,
rastrearon su ejecución manualmente,
escribieron pruebas,
y releyeron las especificaciones frecuentemente,
todos habitos que se pueden enseñar.
Sin embargo,
rastrear la ejecución paso a paso a veces se usaba de manera ineficaz:
por ejemplo,
una persona novata podría poner la misma declaración \texttt{print} en ambas parte de una estructura \texttt{if}-\texttt{else}.
Las personas novatas también comentarían líneas de código que en realidad eran correctas al tratar de aislar un problema;
las/los docentes puede comentern estos dos errores deliberadamente, 
señalarlos,
y corregirlos para ayudar a las personas novatas a aprender a resolverlos.

Enseñar a personas novatas como depurar errores también puede ayudar a que las clases sean más simples de manejar.
\cite{Alqa2017} encontró que estudiantes con mayor experiencia resolvieron problemas de depuración de errores significativamente más rápido,
pero los tiempos variaron ampliamente:
4--10 minutos fue el rango típico para ejercicios individuales,
lo que significa que algunas/os estudiantes necesitan 2--3 más tiempo que otros para resolver el mismo ejercicio.
Enseñar a estudiantes que hacen las cosas más lentamente lo que las personas más rápidas están haciendo
va a ayudar a que el progreso de todo el grupo en general sea más unifirme.

La depuración de errores depende de ser capaz de leer el código,
que múltiples estudios han demostrado que es la forma más efectiva de encontrar errores~\cite{Basi1987,Keme2009,Bacc2013}.
La rubrica de calidad de código desarrollada por~\cite{Steg2014,Steg2016a}
es una buena lista de verificación de elementos a revisar,
aunque se presenta mejor de a partes en vez de toda junta.

Hacer que las/los estudiantes lean código y resuman su comportamiento es un buen ejercicio (\secref{s:individual-strategies}),
pero frecuentemente lleva mucho tiempo para ser practicado en clase.
Hacer que las/los estudiantes predigan la salida de un programa justo antes de que sea ejecutado,
por otro lado,
ayuda a reforzar el aprendizaje (\secref{s:classroom-practices})
y además les da la oportunidad ideal para hacer el tipo de preguntas ``que pasaría si''.
Docentes o estudiantes puede además rastrear los cambios en las variables a medida que avanzan,
algo que \cite{Cunn2017} encontró efectivo (\secref{s:exercises-tracing}).

\seclbl{¿Qué pasa con las pruebas?}{s:pck-testing}
\index{testing (software)}

Programadoras/es novatas/os parecen tan reacios a testear software como aquellas personas profesionales.
No hay duda de que hacerlos es valioso---\cite{Cart2017} encontró que
persons novatas con un alto rendimiento dedican mucho tiempo a testear el código,
mientras que las personas novatas con un bajo rendimiento dedican mucho más tiempo a trabajar en el código con errores---y muchas/os docentes
requieren que las/los estudiantes escriban pruebas en las  actividades.
Pero que tan bien lo hacen?
Una respuesta proviene de~\cite{Bria2015},
que calificó el código de las/los estudiantes según la cantidad de situaciones, definidas por la/el docente, que pasaban correctamente las pruebas de los programas,
y, a la inversa, calificó los casos de prueba escritos por estudiantes de acuedo con la cantidad de errores, sembrados deliberadamente, detectados.
Ellos encontraron que las pruebas de novatos usualmente tiene una baja cobertura (es decir, no testean gran parte del código)
y que usualmente testean muchas cosas al mismo tiempo, lo que dificulta determinar las causas de los errores.

Otra respuesta proviene de ~\cite{Edwa2014b},
que examinó todos los errores en el código presentado por personas novatas combinados
e identificó aquellos detectados por el conjunto de pruebas de las/los novatos.
Ellos encontraron que las pruebas de novatos solo detectaban un promedio del 13.6\% de los errores presentes en la totalidad de los programas.
Además,
el 90\% de las pruebas de las/los novatos fueron muy parecidas,
lo que indica que las/los novatos escriben pruebas principalmente para confirmar que el código está haciendo lo que se supone que debe hacer
en lugar de encontrar situaciones en las que no ocurre.
esto
Un enfoque para enseñar mejores prácticas para generar pruebas es 
definir un problema de programación proporcionando un conjunto de prubas que deben ser pasadas
en lugar de una descripción (\secref{s:exercises-classics}).
Sin embargo,
antes de hacerlo 
tómate un momento para ver cuántas pruebas has escrito recientemente en tu propio código recientemte,
y luego decide si estás enseñando lo que crees que las personas deberían hacer,
 o lo que ellos (y tu) realmente hacen.

\seclbl{Do Languages Matter?}{s:pck-language}
\index{blocks-based programming}

T-______he short answer is ``yes'':
novices learn to program faster and learn more
using blocks-based tools like Scratch (\figref{f:pck-scratch})~\cite{Wein2017}.\index{Scratch}
One reason is that blocks-based systems reduce cognitive load by eliminating the possibility of syntax errors.
Another is that block interfaces encourage exploration in a way that text does not:
like all good tools,
Scratch can be learned accidentally~\cite{Malo2010}.

But what happens \emph{after} blocks?
\cite{Chen2018} found that learners whose first programming language was graphical
had higher grades in introductory programming courses
than learners whose first language was textual
when the languages were introduced in or before early adolescent years.
Our sixth recommendation is therefore to
\recommendation{start children and teens with blocks-based interfaces}
before moving to text-based systems.
The age qualification is there because Scratch deliberately looks like it's meant for younger users,
and it can still be hard to convince adults to take it seriously.

\figimg{figures/scratch-program.png}{Scratch}{f:pck-scratch}

Scratch has probably been studied more than any other programming tool.
One example is~\cite{Aiva2016},
which analyzed over 250,000 Scratch projects
and found (among other things) that about 28\% of projects have some blocks that are never called or triggered.
As in the earlier aside about incomplete versus incorrect Java programs,
the authors hypothesize that users may be using these blocks as a scratchpad
to keep track of bits of code they don't (yet) want to throw away.
Another example is~\cite{Grov2017,Mlad2017},
which studied novices learning about loops in Scratch, Logo, and Python.\index{Scratch}\index{Python}
They found that misconceptions about loops are minimized when using a block-based language
rather than a text-based language.
What's more,
as tasks become more complex (such as using nested loops)
the differences become larger.

\begin{aside}{Harder Than Necessary}
  The creators of programming languages make those languages harder to learn by not doing basic usability testing.
  For example,
  \cite{Stef2013} found that,
  ``{\ldots}the three most common words for looping in computer science,
  \texttt{for}, \texttt{while}, and \texttt{foreach},
  were rated as the three most unintuitive choices by non-programmers.''
  Their work shows that C-style syntax (as used in Java and Perl)
  is just as hard for novices to learn as a randomly designed syntax,
  but that the syntax of languages such as Python and Ruby\index{Python}\index{Ruby}
  is significantly easier to learn,
  and the syntax of a language whose features are tested before being added to the language is easier still.
  \cite{Stef2017} is a useful brief summary of what we actually know about designing programming languages
  and why we believe it's true,
  while \cite{Guzd2016} lays out five principles that programming languages for learners should follow.
\end{aside}

\subsection*{Object-Oriented Programming}
\index{object-oriented programming}

Objects and classes are power tools for experienced programmers,
and many educators advocate an \gref{g:objects-first}{objects first} approach to teaching programming
(though they sometimes disagree on exactly what that means~\cite{Benn2007b}).
\cite{Sorv2014} describes and motivates this approach,
and~\cite{Koll2015} describes three generations of tools
designed to support novice programming in object-oriented environments.
-
Introducing objects early has a few challenges.
\cite{Mill2016b} found that most novices using Python\index{Python}
struggled to understand \texttt{self}
(which refers to the current object):
they omitted it in method definitions,
failed to use it when referencing object attributes,
or both.
\cite{Rago2017} found something similar in high school students,
and also found that high school teachers often weren't clear on the concept either.
On balance,
we recommend that teachers \recommendation{start with functions rather than objects},
i.e.\ that learners not be taught how to define classes
until they understand basic control structures and data types.

\subsection*{Type Declarations}
\index{type declarations}

Programmers have argued for decades about whether variables' data types should have to be declared or not,
usually based on their personal experience as professionals
rather than on any kind of data.
\cite{Endr2014,Fisc2015} found that requiring novices to declare variable types does add some complexity to programs,
but it pays off fairly quickly by acting as documentation for a method's use---in particular,
by forestalling questions about what's available and how to use it.

\subsection*{Variable Naming}
\index{variable naming}

\cite{Kern1999} wrote,
``Programmers are often encouraged to use long variable names regardless of context.
This is a mistake: clarity is often achieved through brevity.''
Lots of programmers believe this,
but \cite{Hofm2017} found that using full words in variable names
led to an average of 19\% faster comprehension compared to letters and abbreviations.
In contrast,
\cite{Beni2017} found that using single-letter variable names didn't affect novices' ability to modify code.
This may be because their programs are shorter than professionals'
or because some single-letter variable names have implicit types and meanings.
For example,
most programmers assume that \texttt{i}, \texttt{j}, and \texttt{n} are integers
and that \texttt{s} is a string,
while \texttt{x}, \texttt{y}, and \texttt{z} are either floating-point numbers or integers
more or less equally.

How important is this?
\cite{Bink2012} reported that reading and understanding code is fundamentally different from reading prose:
``{\ldots}the more formal structure and syntax of source code
allows programmers to assimilate and comprehend parts of the code quite rapidly independent of style.
In particular{\ldots}beacons and program plans play a large role in comprehension.''
It also found that experienced developers are relatively unaffected by identifier style,
so our recommendation is just to use consistent style in all examples.
Since most languages have style guides
(e.g.\ \hreffoot{https://www.python.org/dev/peps/pep-0008/}{PEP 8} for Python)
and tools to check that code follows these guidelines,
our full recommendation is to
\recommendation{use tools to ensure that all code examples adhere to a consistent style}.

\seclbl{Do Better Error Messages Help?}{s:pck-error}
\index{error messages}

Incomprehensible error messages are a major source of frustration for novices
(and for experienced programmers as well).
Several researchers have therefore explored whether better error messages would help alleviate this.
For example,
\cite{Beck2016} rewrote some of the Java compiler's messages so that instead of:

\begin{minted}{text}
C:\stj\Hello.java:2: error: cannot find symbol
        public static void main(string[ ] args)
^
1 error
Process terminated ... there were problems.
\end{minted}

\noindent
learners would see:

\begin{minted}{text}
Looks like a problem on line number 2.
If "string" refers to a datatype, capitalize the 's'!
\end{minted}

\noindent
Sure enough,
novices given these messages made fewer repeated errors and fewer errors overall.

\cite{Bari2017} went further and used eye tracking to show that
despite the grumblings of compiler writers,
people really do read error messages---in fact, they spend 13--25\% of their time doing this.
However,
reading error messages turns out to be as difficult as reading source code,
and how difficult it is to read the error messages strongly predicts task performance.
Teachers should therefore
\recommendation{show learners how to read and interpret error messages}.
\cite{Marc2011} has a rubric for responses to error messages that can be useful in grading such exercises.

\subsection*{Does Visualization Help?}
\index{program visualization}

Visualizing program execution is a perennially popular idea,
and tools like the Online Python Tutor~\cite{Guo2013}
and \hreffoot{http://latentflip.com/loupe/}{Loupe}
(which shows how JavaScript's event loop works)
are useful teaching aids.
However,
people learn more from constructing visualizations
than they do from viewing visualizations constructed by others \cite{Stas1998,Ceti2016},
so does visualization actually help learning?

To answer this,
\cite{Cunn2017} replicated an earlier study of the kinds of sketching learners do when tracing code execution.
They found that not sketching at all correlates with lower success,
while tracing changes to variables' values by writing new values near their names as they change was the most effective strategy.

One possible confounding effect they checked was time:
since sketchers take significantly more time to solve problems,
do they do better just because they think for longer?
The answer is no:
there was no correlation between the time taken and the score achieved.
Our recommendation is therefore to \recommendation{teach learners to trace variables' values when debugging}.

\begin{aside}{Flowcharts}\index{flowcharts}
  One often-overlooked finding about visualization is that
  people understand flowcharts better than pseudocode \emph{if both are equally well structured}~\cite{Scan1989}.
  Earlier work showing that pseudocode outperformed flowcharts used structured pseudocode and tangled flowcharts;
  when the playing field was leveled,
  novices did better with the graphical representation.
\end{aside}

\seclbl{What Else Can We Do to Help?}{s:pck-help}

\cite{Viha2014} examined the average improvement in pass rates of various kinds of intervention in programming classes.
They point out that there are many reasons to take their findings with a grain of salt:
the pre-change teaching practices are rarely stated clearly,
the quality of change is not judged,
and only 8.3\% of studies reported negative findings,
so either there is positive reporting bias
or the way we're teaching right now is the worst possible and anything would be an improvement.
And like many other studies discussed in this chapter,
they were only looking at university classes,
so their findings may not generalize to other groups.

With those caveats in mind,
they found ten things teachers can do to improve outcomes (\figref{f:pck-interventions}):

\begin{description}

\item[Collaboration:]
  Activities that encourage learner collaboration either in classrooms or labs.

\item[Content Change:]
  Parts of the teaching material were changed or updated.

\item[Contextualization:]
  Course content and activities were aligned towards a specific context such as games or media.

\item[CS0:]
  Creation of a preliminary course to be taken before the introductory programming course;
  could be organized only for some (e.g.\ at-risk) learners.

\item[Game Theme:]
  A game-themed component was introduced to the course.

\item[Grading Scheme:]
  A change in the grading scheme,
  such as increasing the weight of programming activities while reducing that of the exam.

\item[Group Work:]
  Activities with increased group work commitment such as team-based learning and cooperative learning.

\item[Media Computation:]
  Activities explicitly declaring the use of media computation (\chapref{s:motivation}).

\item[Peer Support:]
  Support by peers in form of pairs, groups, hired peer mentors or tutors.

\item[Other Support:]
  An umbrella term for all support activities,
  e.g.\ increased teacher hours, additional support channels, etc.

\end{description}

\figimg{figures/interventions-scaled.png}{Effectiveness of interventions}{f:pck-interventions}

This list highlights the importance of cooperative learning.
\cite{Beck2013} looked at this specifically over three academic years in courses taught by two different teachers
and found significant benefits overall and for many subgroups.
The cooperators had higher grades
and left fewer questions blank on the final exam,
which indicates greater self-efficacy and willingness to try to debug things.

\begin{aside}{Computing Without Coding}
  Writing code isn't the only way to teach people how to program:
  having novices work on computational creativity exercises improves grades at several levels~\cite{Shel2017}.
  A typical exercise is to describe an everyday object (such as a paper clip or toothbrush)
  in terms of its inputs, outputs, and functions.
  This kind of teaching is sometimes called \grefdex{g:cs-unplugged}{unplugged}{CS unplugged};
  the \hreffoot{https://csunplugged.org/en/}{CS~Unplugged} site has lessons and exercises for doing this.
\end{aside}

\seclbl{Where Next?}{s:pck-final}

For those who want to go deeper,
\cite{Finc2019} is a comprehensive summary of CER,
\cite{Ihan2016} summarizes the methods that studies use most often.
I hope that some day we will have catalogs like~\cite{Ojos2015}
and more teacher training materials like~\cite{Hazz2014,Guzd2015a,Sent2018}
to help us all do better.

Most of the research reported in this chapter was publicly funded
but is locked away behind paywalls:
at a guess,
I broke the law 250 times to download papers from sites like \hreffoot{https://en.wikipedia.org/wiki/Sci-Hub}{Sci-Hub}
while writing this book.\index{illegal downloading (mine)}
I hope the day is coming when no one will need to do that;
if you are a researcher,
please hasten that day by publishing your work in open access venues.

\seclbl{Exercises}{s:pck-exercises}

\exercise{Your Learners' Misunderstandings}{small groups}{15}

Working in small groups,
re-read \secref{s:pck-misunderstand} and make a list of misconceptions you think your learners have.
How specific are they?
How would you check how accurate your list is?

\exercise{Checking for Common Errors}{individual}{20}

These common errors are taken from a longer list in~\cite{Sirk2012}:

\begin{description}

\item[Inverted assignment:]
  The learner assigns the value of the left-hand variable to the right-hand variable
  rather than the other way around.

\item[Wrong branch:]
  The learner thinks the code in the body of an \texttt{if} is run
  even if the condition is false.

\item[Executing function instead of defining it:]
  The learner believes that a function is executed as it is defined.

\end{description}

\noindent
Write one exercise for each to check that learners \emph{aren't} making that mistake.

\exercise{Mangled Code}{pairs}{15}

\cite{Chen2017} describes exercises in which learners reconstruct code that has been mangled
by removing comments,
deleting or replacing lines of code,
moving lines,
and so on.
Performance on these correlates strongly with performance on assessments
in which learners write code,
but these questions require less work to mark.
Take the solution to a programming exercise you've created in the past,
mangle it in two different ways,
swap with a partner,
and see how long it takes each of you to answer the other's question correctly.

\exercise{The Rainfall Problem}{pairs}{10}

\cite{Solo1986} introduced the Rainfall Problem,
which has been used in many subsequent studies of programming~\cite{Fisl2014,Simo2013,Sepp2015}.
Write a program that repeatedly reads in positive integers until it reads the integer 99999.
After seeing 99999,
the program prints the average of the numbers seen.

\begin{enumerate}

\item
  Solve the Rainfall Problem in the programming language of your choice.

\item
  Compare your solution with that of your partner.
  What does yours do that theirs doesn't and vice versa?

\end{enumerate}

\exercise{Roles of Variables}{pairs}{15}

\cite{Kuit2004,Byck2005,Saja2006} presented a set of single-variable patterns
that I have found very useful in teaching beginners:

\begin{description}

\item[Fixed value:]
  A data item that does not get a new proper value after its initialization.

\item[Stepper:]
  A data item stepping through a systematic, predictable succession of values.

\item[Walker:]
  A data item traversing in a data structure.

\item[Most-recent holder:]
  A data item holding the latest value encountered
  while going through a succession of values.

\item[Most-wanted holder:]
  A data item holding the best or most appropriate value encountered so far.

\item[Gatherer:]
  A data item accumulating the effect of individual values.

\item[Follower:]
  A data item that always gets its new value from the old value of some other data item.

\item[One-way flag:]
  A two-valued data item that cannot get its initial value once the value has been changed.

\item[Temporary:]
  A data item holding some value for a very short time only.

\item[Organizer:]
  A data structure storing elements that can be rearranged.

\item[Container:]
  A data structure storing elements that can be added and removed.

\end{description}

Choose a 5--15 line program and classify its variables using these categories.
Compare your classifications with those of a partner.
Where you disagreed,
did you understand each other's view?

\exercise{What Are You Teaching?}{individual}{10}

Compare the topics you teach to the list developed in~\cite{Luxt2017} (\secref{s:pck-now}).
Which topics do you cover?
Which \emph{don't} you cover?
What extra topics do you cover that aren't in their list?

\exercise{Beneficial Activities}{individual}{10}

Look at the list of interventions developed by~\cite{Viha2014} (\secref{s:pck-help}).
Which of these things do you already do in your classes?
Which ones could you easily add?
Which ones are irrelevant?

\exercise{Misconceptions and Challenges}{small groups}{15}

The \hreffoot{http://www.pd4cs.org/}{Professional Development for CS Principles Teaching} site
includes \hreffoot{http://www.pd4cs.org/mc-index/}{a detailed list of learners' misconceptions and exercises}.
Working in small groups,
choose one section (such as data structures or functions) and go through their list.
Which of these misconceptions do you remember having when you were a learner?
Which do you still have?
Which have you seen in your learners?

\exercise{What Do You Care Most About?}{whole class}{15}

\cite{Denn2019} asked people to propose and rate various CER questions,
and found that there was no overlap between those that researchers cared most about
and those that non-researchers cared most about.
The researchers' favorites were:

\begin{enumerate}

\item
  What fundamental programming concepts are the most challenging for students?

\item
  What teaching strategies are most effective when dealing with a wide range of prior experience in introductory programming classes?

\item
  What affects students' ability to generalize from simple programming examples?

\item
  What teaching practices are most effective for teaching computing to children?

\item
  What kinds of problems do students in programming classes find most engaging?    

\item
  What are the most effective ways to teach programming to various groups?

\item
  What are the most effective ways to scale computing education to reach the general student population?

\end{enumerate}

\noindent
while the most important questions for non-researchers were:

\begin{enumerate}

\item
  How and when is it best to give students feedback on their code to improve learning?

\item
  What kinds of programming exercises are most effective when teaching students Computer Science?

\item
  What are the relative merits of project-based learning, lecturing, and active learning for students learning computing?

\item
  What is the most effective way to provide feedback to students in programming classes?

\item
  What do people find most difficult when breaking problems down into smaller tasks while programming?

\item
  What are the key concepts that students need to understand in introductory computing classes?

\item
  What are the most effective ways to develop computing competency among students in non-computing disciplines?

\item
  What is the best order in which to teach basic computing concepts and skills?

\end{enumerate}

Have each person in the class independently give one point to
each of the eight questions from the combined lists that they care most about,
then calculate an average score for each question.
Which ones are most popular in your class?
In which group are the most popular questions?
